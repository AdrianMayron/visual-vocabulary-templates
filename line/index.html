<!DOCTYPE html>
<html>
<head>
    <title>Line chart - Visual Vocabulary</title>
    <script src="//d3js.org/d3.v4.js"></script>
    <script src="//d3js.org/d3-selection-multi.v1.min.js"></script>
    <script src="https://unpkg.com/g-chartframe"></script>
    <script src="//ft-interactive.github.io/visual-vocabulary/shared/svg2png.js"></script>
    <script src="https://unpkg.com/g-chartcolour"></script>
    <script src="lineChart.js"></script>
    <script src="https://rawgit.com/ft-interactive/g-legend/master/build/g-legend.js"></script>
    <script src="https://rawgit.com/ft-interactive/g-yaxislinear/master/build/g-yaxislinear.js"></script>
    <script src="https://rawgit.com/ft-interactive/g-xaxisdate/master/build/g-xaxisdate.js"></script>
    <link rel="stylesheet" href="styles.css"/>
    <link rel="stylesheet" href="https://www.ft.com/__origami/service/build/v2/bundles/css?modules=o-fonts@^2.2.0" />
    <style>
    .saveable button{ display: block; }
    ul {line-height: 24px;}
    </style>
</head>
<body>

    <h1>Line chart</h1>
    <p>The standard way to show a changing time series. If data are irregular, consider markers to represent data points</p>
    <p><b>Some useful settings in the index.html</b>
        <ul>
            <li><b>yMin</b> and <b>yMax</b> – use these to set the lower and upper values of the y-axis</li>
            <li><b>numTicksy</b> – set the number of scale lines on the y-axis</li>
            <li><b>annotate</b> – set to 'true' will display annotations in your dataset's 'annotate' column</li>
            <li><b>highlightNames</b> – put the column names of the data you want to highlight, all other series will be muted</li>
            <li><b>interval</b> – options available are "century","jubilee" (50 years), decade", "lustrum" (5 years), "years","months","days"</li>
        </ul>
    </p>
     <p><b>Column headings in the csv</b>
        <ul>
            <li><b>annotate</b> – use this column to create annotations for a particular point in time</li>
            <li><b>highlight</b> – use this column to define highlight bands in the background of your chart, add 'begin' where you want the band to start and 'end' where you want it to finish. You can have as many highlights as you want.</li>
        </ul>
    </p>
    <p>Please make sure than the <b>blue line</b> is on top as this is the primary line colour</p>

    <hr>
    <figure class="framed saveable" data-frame="webS"><svg></svg></figure>
    <figure class="framed saveable" data-frame="webM"><svg></svg></figure>
    <figure class="framed saveable" data-frame="webL"><svg></svg></figure>
    <figure class="framed saveable" data-frame="print"><svg></svg></figure>
    <figure class="framed saveable" data-frame="social"><svg></svg></figure>
    <figure class="framed saveable" data-frame="video"><svg></svg></figure>

</body>

<script type="text/javascript">


//User defined constants similar to version 2
const dateStructure = "%d/%m/%Y";

const dataFile = "data.csv";

const sharedConfig = {
  title:"Title not yet added",
  subtitle:"Subtitle not yet added",  
  source:"Source not yet added",
}

let yMin = 0;//sets the minimum value on the yAxis
let yMax = 0;//sets the maximum value on the xAxis
let yAxisHighlight = 100; //sets which tick to highlight on the yAxis
const numTicksy = 4;//Number of tick on the uAxis
const yAxisAlign = "right";//alignment of the axis
const interval = "years"//date interval on xAxis "century", "jubilee", "decade", "lustrum", "years","months","days"
let annotate = true; // show annotations, defined in the 'annotate' column
let markers = false;//show dots on lines
let legendAlign = "vert"//hori or vert, alignment of the legend
let legendType = "line"//hori or vert, alignment of the legend
let minorAxis = true//turns on or off the minor axis
let highlightNames = []; // create an array names you want to highlight eg. ['series1','series2']
let interpolation=d3.curveLinear//curveStep, curveStepBefore, curveStepAfter, curveBasis, curveCardinal, curveCatmullRom

//Individual frame configuratiuon, used to set margins (defaults shown below) etc
const frame = {
   webS: gChartframe.webFrameS(sharedConfig)
   .margin({top:100, left:15, bottom:82, right:5})
   .title("Put headline here") //use this if you need to override the defaults
   // .subtitle("Put headline |here") //use this if you need to override the defaults
   .height(400),

   webM: gChartframe.webFrameM(sharedConfig)
   .margin({top:100, left:20, bottom:86, right:5})
   // .title("Put headline here")
   .height(500),

   webL: gChartframe.webFrameL(sharedConfig)
   .margin({top:100, left:20, bottom:104, right:5})
   // .title("Put headline here")
   .height(700)
   .fullYear(true),

   print: gChartframe.printFrame(sharedConfig)
   .margin({top:40, left:7, bottom:35, right:7})
   // .title("Put headline here")
   .height(68)
   .width(55),

   social: gChartframe.socialFrame(sharedConfig)
   .margin({top:140, left:50, bottom:138, right:40})
   // .title("Put headline here")
   .height(750), // 700 is ideal height for Instagram

   video: gChartframe.videoFrame(sharedConfig)
   .margin({left:207, right:207, bottom:210, top:233})
   // .title("Put headline here")
};


//add the frames to the page...
d3.selectAll('.framed')
    .each(function(){
        const figure = d3.select(this);
        figure.select('svg')
            .call(frame[figure.node().dataset.frame]);
    });

d3.csv(dataFile, function(data) {
    //make sure all the dates in the date column are a date object
    var parseDate = d3.timeParse(dateStructure)
    data.forEach(function(d) {
                d.date=parseDate(d.date);
            });
    //automatically calculate the seriesnames excluding the "marker" and "annotate column"
    let seriesNames=getSeriesNames(data.columns)



    //format the dataset that is used to draw the lines
    let plotData=seriesNames.map(function(d,i){
        return {
            name:d,
            lineData:getlines(data,d)
        }
    })


    const dataSorter = function(a, b){    //Sort the data so that the labeled items are drawn on top
        if(highlightNames.indexOf(a.name) > highlightNames.indexOf(b.name)){
          return 1;
        }else if(highlightNames.indexOf(a.name) == highlightNames.indexOf(b.name)){
          return 0;
        }
        return -1;
    };

    if(highlightNames){ plotData.sort(dataSorter)};

    // filter data for annotations
    const annos = data.filter((d)=> (d.annotate !="" && d.annotate !=undefined))

    //format the data that is used to draw highlight tonal bands
    const boundaries=data.filter((d)=> (d.highlight==="begin" || d.highlight==="end"))
    let highlights=[]
    boundaries.forEach(function(d,i){
        if (d.highlight==="begin") {
            highlights.push({begin: d.date,end:boundaries[i+1].date}) 
        }
    })
    //Use the seriesNames array to calculate the minimum and max values in the dataset
    const valueExtent = extentMulti(data,seriesNames)
    //define the chart x and x domains. yDomain will automatically overwrite the user defined min and max if the domain is too small
    const myChart = lineChart()
        .seriesNames(seriesNames)
        .highlightNames(highlightNames)
        .yDomain([Math.min(yMin,valueExtent[0]),Math.max(yMax,valueExtent[1])])
        .xDomain(d3.extent(data, function(d) {return d.date;}))
        .yAxisAlign(yAxisAlign)
        .markers(markers)
        .annotate(annotate)
        .interpolation(interpolation)


    Object.keys(frame).forEach(frameName=>{
        const currentFrame = frame[frameName];
        //define other functions to be called
        const myYAxis = gAxis.yaxisLinear();//sets up yAxis

        const myXAxis = gAxis.xaxisDate();//sets up xAxis
        const myHighlights = drawHighlights()//sets up highlight tonal bands
        const myAnnotations = drawAnnotations()//sets up annotations
        const myLegend = gLegend.legend()//sets up the legend
        //const plotDim=currentFrame.dimension()//useful variable to carry the current frame dimensions
        const tickSize=currentFrame.dimension().width;//Used when drawing the yAxis ticks

        d3.select(currentFrame.plot().node().parentNode)
            .call(currentFrame);

            
        //create a 'g' element at the back of the chart to add time period highlights after axis have been created
        let axisHighlight = currentFrame.plot().append('g');
       
        //create a 'g' element behind the chart and in front of the highlights
        let plotAnnotation = currentFrame.plot().append('g')
                                .attr('class', 'annotations-holder');

        myChart
            .yRange( [currentFrame.dimension().height,0] )
            .plotDim(currentFrame.dimension())
            .rem(currentFrame.rem())
            .colourPalette((frameName));

        
        myYAxis
            .yScale(myChart.yScale())
            .numTicks(numTicksy)
            .tickSize(tickSize)
            .yAxisHighlight(yAxisHighlight)
            .tickAlign(myChart.yAxisAlign())

        //Draw the yAxis first, this will position the yAxis correctly and measure the width of the label text
        currentFrame.plot()
            .call(myYAxis);
              
        //return the value in the variable newMargin
        if (yAxisAlign=="right") {
            let newMargin = myYAxis.labelWidth()+currentFrame.margin().right
            //Use newMargin redefine the new margin and range of xAxis
            currentFrame.margin({right:newMargin});
        }
        else {
            let newMargin = myYAxis.labelWidth()+currentFrame.margin().left
            //Use newMargin re define the new margin and range of xAxis
            currentFrame.margin({left:newMargin});
        }

        myChart.xRange( [0, currentFrame.dimension().width] );
        //Set up xAxis for this frame
        myXAxis
            .fullYear(currentFrame.fullYear())
            .scale(myChart.xScale())
            .offset(currentFrame.dimension().height)
            .interval(interval)
            .tickSize(myChart.rem())
            .minorAxis(minorAxis);

        //Set up highlights for this frame
        myHighlights
            .yScale(myChart.yScale())
            .yRange( [currentFrame.dimension().height,0] )
            .xScale(myChart.xScale())
            .xRange( [0,currentFrame.dimension().width] );


        //Draw the highlights before the lines and xAxis
        axisHighlight
            .selectAll(".highlights")
            .data(highlights)
            .enter()
            .append("g")
            .call(myHighlights);

        //Draw the xAxis
        currentFrame.plot()
            .call(myXAxis);
        
        //Set up highlights for this frame
        myAnnotations
            .yScale(myChart.yScale())
            .yRange( [currentFrame.dimension().height,0] )
            .xScale(myChart.xScale())
            .xRange( [0,currentFrame.dimension().width] )
            .rem(currentFrame.rem());

        //Draw the annotations before the lines
        plotAnnotation
            .selectAll(".annotation")
            .data(annos)
            .enter()
            .append("g")
            .call(myAnnotations);

        //Draw the lines  
        currentFrame.plot()
            .selectAll("lines")
            .data(plotData)
            .enter()
            .append("g")
            .attr('class','lines')
            .call(myChart);

        //Set up legend for this frame
        myLegend
            .seriesNames(seriesNames, highlightNames)
            .colourPalette((frameName))
            .rem(myChart.rem())
            .geometry(legendType)
            .alignment(legendAlign);
        //Draw the Legend
        currentFrame.plot()
            .append("g")
            .attr("id","legend")
                .selectAll(".legend")
                .data(function () {
                     if(highlightNames.length > 0) {
                        return highlightNames;
                    } else {
                        return seriesNames;
                    }

                    })
                .enter()
                .append("g")
                .classed("legend",true)
            .call(myLegend)

     });
    // addSVGSavers('figure.saveable');
});

//a function that returns the columns headers from the top of the dataset, excluding specified
function getSeriesNames(columns){
    var exclude = ['date','annotate','highlight'];
    return columns.filter(d=>(exclude.indexOf(d) == -1));
}

//a function to work out the extent of values in an array accross multiple properties...
function extentMulti(data, columns){
    const ext = data.reduce((acc, row, index)=>{
        let values = columns.map(key=> +row[key])
        let rowExtent = d3.extent(values);
        if(!acc.max){
            acc.max = rowExtent[1];
            acc.min = rowExtent[0];
        }else{
            acc.max = Math.max(acc.max, rowExtent[1]);
            acc.min = Math.min(acc.min, rowExtent[0]);
        }
        return acc;
    },{});
    return [ext.min, ext.max];
}
//a function that sort the column information in the dataset into groups according to the column head, so that the line path can be passed as one object to the drawing function
function getlines(data,group) {
    let lineData=[]
    data.forEach(function(el,i){
        //console.log(el,i)
        let column=new Object();
        column.name = group
        column.date = el.date
        column.value = +el[group]
        column.highlight = el.highlight
        column.annotate = el.annotate
        if(el[group]) {
            lineData.push(column)  
        } 
    });
    return lineData
}

</script>
</html>
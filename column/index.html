<!DOCTYPE html>
<html>
<head>
    <title>Column chart - Visual Vocabulary</title>
    <script src="//d3js.org/d3.v4.js"></script>
    <script src="//d3js.org/d3-selection-multi.v1.min.js"></script>
    <script src="https://unpkg.com/g-chartframe"></script>
    <script src="//ft-interactive.github.io/visual-vocabulary/shared/svg2png.js"></script>
    <script src="https://unpkg.com/g-chartcolour"></script>
    <script src="main.js"></script>
    <script src="legend.js"></script>
    <!-- Uncomment which axes you need to include for your chart -->
    <script src="https://rawgit.com/ft-interactive/g-yaxislinear/master/build/g-yaxislinear.js"></script>
    <!-- <script src="https://rawgit.com/ft-interactive/g-yaxisOrdinal/master/build/g-yaxisOrdinal.js"></script> -->
    <!-- <script src="https://rawgit.com/ft-interactive/g-xaxisdate/master/build/g-xaxisdate.js"></script> -->
    <script src="xAxisOrdinal.js"></script>
    <!-- <script src="https://rawgit.com/ft-interactive/g-xaxisOrdinal/master/build/g-xaxisOrdinal.js"></script> -->
    <!-- <script src="https://rawgit.com/ft-interactive/g-xaxisLinear/master/build/g-xaxisLinear.js"></script> -->
    <link rel="stylesheet" href="styles.css"/>
    <link rel="stylesheet" href="https://www.ft.com/__origami/service/build/v2/bundles/css?modules=o-fonts@^2.2.0" />
    <style>
    .saveable button{ display: block; }
    </style>
</head>
<body>

    <h1>Column chart</h1>
    <p>A suggested starting point for creating cross-platform artisinal charts with default FT styling</p>
    <hr>
    <figure class="framed saveable" data-frame="webS"><svg></svg></figure>
    <figure class="framed saveable" data-frame="webM"><svg></svg></figure>
    <figure class="framed saveable" data-frame="webL"><svg></svg></figure>
    <figure class="framed saveable" data-frame="print"><svg></svg></figure>
    <figure class="framed saveable" data-frame="social"><svg></svg></figure>
    <figure class="framed saveable" data-frame="video"><svg></svg></figure>

</body>

<script type="text/javascript">

//User defined constants similar to version 2
const dateStructure = "%d/%m/%Y";

const dataFile = "data.csv"

const sharedConfig = {
  title:"Title not yet added",
  subtitle:"Subtitle not yet added",  
  source:"Source not yet added",
}
let yMin = 0;//sets the minimum value on the yAxis
let yMax = 0;//sets the maximum value on the xAxis
const yAxisHighlight = 100; //sets which tick to highlight on the yAxis
const numTicksy = 5;//Number of tick on the uAxis
const yAxisAlign = "right";//alignment of the axis
const xAxisAlign = "bottom";//alignment of the axis
// const interval = "years"//date interval on xAxis "decade", "lustrum", "years","months","days"
// let annotate = true; // show annotations, defined in the 'annotate' column
// let markers = false;//show dots on lines
let legendAlign = "vert"//hori or vert, alignment of the legend
let legendType = 'circ' //rect, line or circ, geometry of legend marker
// let interpolation=d3.curveLinear//curveStep, curveStepBefore, curveStepAfter, curveBasis, curveCardinal, curveCatmullRom
// let minorAxis = true//turns on or off the minor axis

//Individual frame configuratiuon, used to set margins (defaults shown below) etc
const frame = {
   webS: gChartframe.webFrameS(sharedConfig)
   .margin({top:100, left:15, bottom:82, right:5})
   // .title("Put headline here") //use this if you need to override the defaults
   // .subtitle("Put headline |here") //use this if you need to override the defaults
   .height(400),

   webM: gChartframe.webFrameM(sharedConfig)
   .margin({top:100, left:20, bottom:86, right:5})
   // .title("Put headline here")
   .height(500),

   webL: gChartframe.webFrameL(sharedConfig)
   .margin({top:100, left:20, bottom:104, right:5})
   // .title("Put headline here")
   .height(700)
   .fullYear(true),

   print: gChartframe.printFrame(sharedConfig)
   .margin({top:40, left:7, bottom:35, right:7})
   // .title("Put headline here")
   .height(69.85)
   .width(55),

   social: gChartframe.socialFrame(sharedConfig)
   .margin({top:140, left:50, bottom:138, right:40})
   // .title("Put headline here")
   .height(750), // 700 is ideal height for Instagram

   video: gChartframe.videoFrame(sharedConfig)
   .margin({left:207, right:207, bottom:210, top:233})
   // .title("Put headline here")
};


//add the frames to the page...
d3.selectAll('.framed')
    .each(function(){
        const figure = d3.select(this);
        figure.select('svg')
            .call(frame[figure.node().dataset.frame]);
    });

d3.csv(dataFile, function(data) {
    //make sure all the dates in the date column are a date object
    // var parseDate = d3.timeParse("%d/%m/%Y")
    // data.forEach(function(d) {
    //             d.date=parseDate(d.date);
    //         });

    //automatically calculate the seriesnames excluding the "name" column
    const seriesNames = getSeriesNames(data.columns)
   
    //Use the seriesNames array to calculate the minimum and max values in the dataset
    const valueExtent = extentMulti(data,seriesNames)

    console.log(valueExtent)
    const columnNames = [ ...new Set(data.map(d=>d.name)) ]; // create an array of the column names

    //define chart
    const myChart = columnChart()
          .seriesNames(seriesNames)
          .yAxisAlign(yAxisAlign)
    
    //Buid the dataset for plotting
    let plotData = data.map(function(d) {
        return {
            name:d.name,
            groups:getGroups(d),
        }
    });

    console.log(plotData);

    function getGroups(el) {
        var groups = seriesNames.map(function(name,i) {
            return {
                name: name,
                value: +el[name]
            }
        });
       return groups
    }


    Object.keys(frame).forEach(frameName=>{
        const currentFrame = frame[frameName];

        const myXAxis0 = xAxisOrdinal();//sets up yAxis
        const myXAxis1 = xAxisOrdinal();//sets up yAxis
        const myYAxis = gAxis.yaxisLinear();
        const myChart = columnChart();
        const myLegend = drawLegend();

        //define other functions to be called
        const tickSize = currentFrame.dimension().width;//Used when drawing the yAxis ticks

        myChart
            .yRange( [currentFrame.dimension().height,0] )
            .plotDim(currentFrame.dimension())
            .rem(currentFrame.rem())
            .colourPalette((frameName));

        myYAxis
            .yScale(myChart.yScale())
            .numTicks(numTicksy)
            .tickSize(tickSize)
            .yAxisHighlight(yAxisHighlight)
            .tickAlign(myChart.yAxisAlign())

        myYAxis
            .tickAlign(yAxisAlign)
            .domain([Math.min(yMin,valueExtent[0]),Math.max(yMax,valueExtent[1])])
            .numTicks(numTicksy)

        let base = currentFrame.plot().append("g")
        
        currentFrame.plot()
          .call(myYAxis);


         //return the value in the variable newMargin
        if (yAxisAlign=="right") {
            let newMargin = myYAxis.labelWidth()+currentFrame.margin().right
            //Use newMargin redefine the new margin and range of xAxis
            currentFrame.margin({right:newMargin});
        }
        else {
            let newMargin = myYAxis.labelWidth()+currentFrame.margin().left
            //Use newMargin re define the new margin and range of xAxis
            currentFrame.margin({left:newMargin});
        }

        d3.select(currentFrame.plot().node().parentNode)
            .call(currentFrame);

        myXAxis0
            .align(xAxisAlign)
            .domain(columnNames)
            .rangeRound([0,currentFrame.dimension().width],10)
            .offset(currentFrame.dimension().height + currentFrame.rem()/2)
        myXAxis1
            .align(xAxisAlign)
            .domain(seriesNames)
            .rangeRound([0,myXAxis0.bandwidth()])

        myChart
            .xScale0(myXAxis0.scale())
            .xScale1(myXAxis1.scale())
            // .yScale(myYAxis.yScale())

        currentFrame.plot()
          .call(myXAxis0)


        currentFrame.plot()
          .selectAll(".columnHolder")
          .data(plotData)
          .enter()
          .append("g")
          .attr('class', 'columnHolder')
          .call(myChart)


        //Set up legend for this frame
        myLegend
            .seriesNames(seriesNames)
            .geometry(legendType)
            .rem(myChart.rem())
            .alignment(legendAlign)
            .colourPalette((frameName));

        //Draw the Legend
        currentFrame.plot()
            .append("g")
            .attr("id","legend")
                .selectAll(".legend")
                .data(seriesNames)
                .enter()
                .append("g")
                .classed("legend",true)
            .call(myLegend)
    });
    // addSVGSavers('figure.saveable');
});

//a function that returns the columns headers from the top of the dataset, excluding specified
function getSeriesNames(columns){
    var exclude = ['name']; // adjust column headings to match your dataset
    return columns.filter(d=>(exclude.indexOf(d) == -1));
}

//a function to work out the extent of values in an array accross multiple properties...
function extentMulti(data, columns){
    const ext = data.reduce((acc, row, index)=>{
        let values = columns.map(key=> +row[key])
        let rowExtent = d3.extent(values);
        if(!acc.max){
            acc.max = rowExtent[1];
            acc.min = rowExtent[0];
        }else{
            acc.max = Math.max(acc.max, rowExtent[1]);
            acc.min = Math.min(acc.min, rowExtent[0]);
        }
        return acc;
    },{});
    return [ext.min, ext.max];
}


</script>
</html>
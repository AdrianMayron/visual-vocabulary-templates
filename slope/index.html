<!DOCTYPE html>
<html>
<head>
    <title>Slope chart - Visual Vocabulary</title>
    <script src="//d3js.org/d3.v4.js"></script>
    <script src="//d3js.org/d3-selection-multi.v1.min.js"></script>
    <script src="https://unpkg.com/g-chartframe"></script>
    <script src="//ft-interactive.github.io/visual-vocabulary/shared/svg2png.js"></script>
    <script src="https://unpkg.com/g-chartcolour"></script>
    <script src="slope.js"></script>
    <script src="https://rawgit.com/ft-interactive/g-legend/master/build/g-legend.js"></script>
    <link rel="stylesheet" href="styles.css"/>
    <link rel="stylesheet" href="https://www.ft.com/__origami/service/build/v2/bundles/css?modules=o-fonts@^2.2.0" />
    <style>
    .saveable button{ display: block; }
    ul {line-height: 24px;}
    </style>
</head>
<body>

    <h1>Slope chart</h1>
    <p>Good for showing changing data as long as the data can be simplified into 2 or 3 points without missing a key part of story.</p>
    <p><b>Some useful settings in the index.html</b>
        <ul>
            <li><b>yMin</b> and <b>yMax</b> – use these to set the lower and upper values of the y-axis</li>
            <li><b>numTicksy</b> – set the number of scale lines on the y-axis</li>
        </ul>
    </p>
    <p><b>Column headings in the csv</b>
        <ul>
            <li><b>label</b> – use this column to turn the label on for a particular line, by putting 'yes' in the column</li>
            <li><b>group</b> – use this column to group lines together, you can have up to 7 groups but ideally no more than four</li>
        </ul>
    </p>
    <p>Please make sure than the <b>blue line</b> is on top as this is the primary line colour</p>
    <hr>
    <figure class="framed saveable" data-frame="webS"><svg></svg></figure>
    <figure class="framed saveable" data-frame="webM"><svg></svg></figure>
    <figure class="framed saveable" data-frame="webL"><svg></svg></figure>
    <figure class="framed saveable" data-frame="print"><svg></svg></figure>
    <figure class="framed saveable" data-frame="social"><svg></svg></figure>
    <figure class="framed saveable" data-frame="video"><svg></svg></figure>

</body>

<script type="text/javascript">

//User defined constants similar to version 2
const dateStructure = "%d/%m/%Y";
const sharedConfig = {
  title:"Title not yet added",
  subtitle:"Subtitle not yet added",  
  source:"Source not yet added"
}
let yMin = 0;//sets the minimum value on the yAxis
let yMax = 0;//sets the maximum value on the xAxis
const yAxisHighlight = 0; //sets which tick to highlight on the yAxis
const numTicksy = 5;//Number of tick on the uAxis
const yAxisAlign = "right";//alignment of the axis
let legendAlign = "vert";//hori or vert, alignment of the legend
let legendType = "line";//rect, line or circ, geometry of legend marker

//Individual frame configuratiuon, used to set margins (defaults shown below) etc
const frame = {
   webS: gChartframe.webFrameS(sharedConfig)
   .margin({top:100, left:80, bottom:62, right:80})
   // .title("Put headline here") //use this if you need to override the defaults
   // .subtitle("Put headline |here") //use this if you need to override the defaults
   .height(400)
   .sourcePlotYOffset(24),

   webM: gChartframe.webFrameM(sharedConfig)
   .margin({top:100, left:100, bottom:62, right:100})
   // .title("Put headline here")
   .height(500)
   .sourcePlotYOffset(28),

   webL: gChartframe.webFrameL(sharedConfig)
   .margin({top:100, left:150, bottom:76, right:150})
   // .title("Put headline here")
   .height(700)
   .sourcePlotYOffset(32)
   .fullYear(true),

   print: gChartframe.printFrame(sharedConfig)
   .margin({top:40, left:40, bottom:35, right:40})
   // .title("Put headline here")
   .height(90)
   .width(55),

   social: gChartframe.socialFrame(sharedConfig)
   .margin({top:140, left:150, bottom:138, right:150})
   // .title("Put headline here")
   .height(750), // 700 is ideal height for Instagram

   video: gChartframe.videoFrame(sharedConfig)
   .margin({left:400, right:400, bottom:210, top:233})
   // .title("Put headline here")
};


//add the frames to the page...
d3.selectAll('.framed')
    .each(function(){
        const figure = d3.select(this);
        figure.select('svg')
            .call(frame[figure.node().dataset.frame]);
    });

d3.csv('data.csv', function(data) {
    //make sure all the dates in the date column are a date object
    // var parseDate = d3.timeParse("%d/%m/%Y")
    // data.forEach(function(d) {
    //             d.date=parseDate(d.date);
    //         });

    //automatically calculate the seriesnames excluding the "marker" and "annotate column"
    let seriesNames = getSeriesNames(data.columns);

    const groupNames = [ ...new Set(data.map(d=>d.group)) ].filter(d=>d); // create an array of the group names

    const dataSorter = function(a, b){    //Sort the data so that the labeled items are drawn on top
        if(groupNames.indexOf(a.group) > groupNames.indexOf(b.group)){
          return 1;
        }else if(groupNames.indexOf(a.group) == groupNames.indexOf(b.group)){
          return 0;
        }
        return -1;
    };

    //Use the seriesNames array to calculate the minimum and max values in the dataset
    const valueExtent = extentMulti(data,seriesNames);
    data.sort(dataSorter);

    const valueFormat = d=>d3.format(',')(d)

    //define chart
    const myChart = slopeChart()
          .colourProperty( 'group' )
          .groupNames(groupNames)
          .xDomain( seriesNames )
          .yDomain( [Math.min(yMin,valueExtent[0]),Math.max(yMax,valueExtent[1])] )
          .yAxisAlign(yAxisAlign)
          .includeLabel( (row)=> (row.label === 'yes') )
          .labelTextStart( (row)=> (row.name + ' ' + valueFormat(row[seriesNames[0]])) )
          .labelTextEnd( (row)=> (row.name + ' ' + valueFormat(row[seriesNames[1]])) );
          



          // .plotDim(currentFrame.dimension())
          // .rem(currentFrame.rem())
          // .colourPalette((frameName));
    //general axes configuration

    const myAxes = slopeAxes()
              .startLabel(seriesNames[0])
              .endLabel(seriesNames[1])
              .yAxisHighlight(yAxisHighlight); // y-axis tick to highlight, if chart is rebased put 100 here
             

    Object.keys(frame).forEach(frameName=>{
        const currentFrame = frame[frameName];
        const myLegend = gLegend.legend()//sets up the legend
        
        myChart
        .yRange( [currentFrame.dimension().height,0] )
        .xRange( [0, currentFrame.dimension().width] )
        .rem(currentFrame.rem())
       
        myAxes.xScale( myChart.xScale() )
            .yScale( myChart.yScale() );

        // specifics based on frame type

        //set y-axis tick label offset
        myAxes.tickOffset(-currentFrame.rem() / 4);

        //set start/end label offset
        myAxes.labelOffset(-currentFrame.rem() * 1.3);
        
        // set radius of circles
        myChart.dotRadius(currentFrame.rem() * 0.3);

        // specifics based on frame type
        myChart.colourPalette(frameName, groupNames); // set colour palette
        myAxes.colourInverse((frameName === 'social' || frameName === 'video'));


        currentFrame.plot()
            .call( myAxes );

        currentFrame.plot()
          .selectAll( 'g.slope' )
          .data( data )
          .enter()
          .append( 'g' )
              .attr('class','slope')
              .attr('id', function(d) { return d.name; } )
          .call(myChart);

          //Set up legend for this frame
        myLegend
            .seriesNames(groupNames)
            .colourPalette(frameName)
            .rem(myChart.rem())
            .alignment(legendAlign)
            .geometry(legendType);
       
       //Draw the Legend
        currentFrame.plot()
            .append("g")
            .attr("id","legend")
                .selectAll(".legend")
                .data(groupNames)
                .enter()
                .append("g")
                .classed("legend",true)
            .call(myLegend)
      
        // override chartframe margin.top to allow room for axis labels
        currentFrame.plot()
          .attr('transform', 'translate(' + currentFrame.margin().left + ',' +  (currentFrame.margin().top + currentFrame.rem() * 1.2) + ' )')
    });
    // addSVGSavers('figure.saveable');
});

//a function that returns the columns headers from the top of the dataset, excluding specified
function getSeriesNames(columns){
    var exclude = ['name','group','label']; // adjust column headings to match your dataset
    return columns.filter(d=>(exclude.indexOf(d) == -1));
}

//a function to work out the extent of values in an array accross multiple properties...
function extentMulti(data, columns){
    const ext = data.reduce((acc, row, index)=>{
        let values = columns.map(key=> +row[key])
        let rowExtent = d3.extent(values);
        if(!acc.max){
            acc.max = rowExtent[1];
            acc.min = rowExtent[0];
        }else{
            acc.max = Math.max(acc.max, rowExtent[1]);
            acc.min = Math.min(acc.min, rowExtent[0]);
        }
        return acc;
    },{});
    return [ext.min, ext.max];
}


</script>
</html>